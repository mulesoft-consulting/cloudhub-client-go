/*
Exchange Assets

Description of the Exchange Assets API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package exchange_assets

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiAssetsOrgIdAssetIdAssetGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	assetId string
}

func (r DefaultApiAssetsOrgIdAssetIdAssetGetRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.AssetsOrgIdAssetIdAssetGetExecute(r)
}

/*
AssetsOrgIdAssetIdAssetGet Get one specific Asset

Get one specific Asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param assetId The ID of the asset
 @return DefaultApiAssetsOrgIdAssetIdAssetGetRequest
*/
func (a *DefaultApiService) AssetsOrgIdAssetIdAssetGet(ctx context.Context, orgId string, assetId string) DefaultApiAssetsOrgIdAssetIdAssetGetRequest {
	return DefaultApiAssetsOrgIdAssetIdAssetGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		assetId: assetId,
	}
}

// Execute executes the request
//  @return Asset
func (a *DefaultApiService) AssetsOrgIdAssetIdAssetGetExecute(r DefaultApiAssetsOrgIdAssetIdAssetGetRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsOrgIdAssetIdAssetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets/{orgId}/{assetId}/asset"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assetId"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiAssetsOrgIdAssetIdPatchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	assetId string
	patchAssetNameAndDescr *PatchAssetNameAndDescr
}

func (r DefaultApiAssetsOrgIdAssetIdPatchRequest) PatchAssetNameAndDescr(patchAssetNameAndDescr PatchAssetNameAndDescr) DefaultApiAssetsOrgIdAssetIdPatchRequest {
	r.patchAssetNameAndDescr = &patchAssetNameAndDescr
	return r
}

func (r DefaultApiAssetsOrgIdAssetIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssetsOrgIdAssetIdPatchExecute(r)
}

/*
AssetsOrgIdAssetIdPatch update Asset name and description

Modify an asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param assetId The ID of the asset
 @return DefaultApiAssetsOrgIdAssetIdPatchRequest
*/
func (a *DefaultApiService) AssetsOrgIdAssetIdPatch(ctx context.Context, orgId string, assetId string) DefaultApiAssetsOrgIdAssetIdPatchRequest {
	return DefaultApiAssetsOrgIdAssetIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		assetId: assetId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AssetsOrgIdAssetIdPatchExecute(r DefaultApiAssetsOrgIdAssetIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsOrgIdAssetIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets/{orgId}/{assetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assetId"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchAssetNameAndDescr
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	assetId string
	version string
}

func (r DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.AssetsOrgIdAssetIdVersionAssetGetExecute(r)
}

/*
AssetsOrgIdAssetIdVersionAssetGet Get Asset by Version

Get one specific Asset by version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param assetId The ID of the asset
 @param version The version of the asset
 @return DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest
*/
func (a *DefaultApiService) AssetsOrgIdAssetIdVersionAssetGet(ctx context.Context, orgId string, assetId string, version string) DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest {
	return DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		assetId: assetId,
		version: version,
	}
}

// Execute executes the request
//  @return Asset
func (a *DefaultApiService) AssetsOrgIdAssetIdVersionAssetGetExecute(r DefaultApiAssetsOrgIdAssetIdVersionAssetGetRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsOrgIdAssetIdVersionAssetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets/{orgId}/{assetId}/{version}/asset"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assetId"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	assetId string
	version string
	xDeleteType *string
}

// It could be &#39;soft-delete&#39; or &#39;hard-delete&#39;, that mean the asset will be logical deleted or physical deleted It&#39;s supposed to if it is not specified, the type will be &#39;soft-delete&#39;
func (r DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest) XDeleteType(xDeleteType string) DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest {
	r.xDeleteType = &xDeleteType
	return r
}

func (r DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssetsOrgIdAssetIdVersionDeleteExecute(r)
}

/*
AssetsOrgIdAssetIdVersionDelete Delete an asset

Delete an asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param assetId The ID of the asset
 @param version The version of the asset
 @return DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest
*/
func (a *DefaultApiService) AssetsOrgIdAssetIdVersionDelete(ctx context.Context, orgId string, assetId string, version string) DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest {
	return DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		assetId: assetId,
		version: version,
	}
}

// Execute executes the request
func (a *DefaultApiService) AssetsOrgIdAssetIdVersionDeleteExecute(r DefaultApiAssetsOrgIdAssetIdVersionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsOrgIdAssetIdVersionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets/{orgId}/{assetId}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assetId"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xDeleteType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Delete-Type", r.xDeleteType, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiAssetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xStrictPackage *bool
	organizationId *string
	assetId *string
	version *string
	name *string
	classifier *string
	groupId *string
	asset *os.File
	xAllowedApiSpecFormats *string
	apiVersion *string
	main *string
	dependencies *string
	originalFormatVersion *string
	metadata *string
	tags *string
	assetLink *string
}

// Indicates if file is immutable.
func (r DefaultApiAssetsPostRequest) XStrictPackage(xStrictPackage bool) DefaultApiAssetsPostRequest {
	r.xStrictPackage = &xStrictPackage
	return r
}

// The id of the organization the asset will belong to
func (r DefaultApiAssetsPostRequest) OrganizationId(organizationId string) DefaultApiAssetsPostRequest {
	r.organizationId = &organizationId
	return r
}

// The id of the asset
func (r DefaultApiAssetsPostRequest) AssetId(assetId string) DefaultApiAssetsPostRequest {
	r.assetId = &assetId
	return r
}

// The version of the asset being created (must follow Semver syntax)
func (r DefaultApiAssetsPostRequest) Version(version string) DefaultApiAssetsPostRequest {
	r.version = &version
	return r
}

// The visible name of the asset
func (r DefaultApiAssetsPostRequest) Name(name string) DefaultApiAssetsPostRequest {
	r.name = &name
	return r
}

// The type of the asset to be created
func (r DefaultApiAssetsPostRequest) Classifier(classifier string) DefaultApiAssetsPostRequest {
	r.classifier = &classifier
	return r
}

// The id of the business group the asset will belong to
func (r DefaultApiAssetsPostRequest) GroupId(groupId string) DefaultApiAssetsPostRequest {
	r.groupId = &groupId
	return r
}

// The asset file. Required for \\\&quot;raml\\\&quot;, \\\&quot;raml-fragment\\\&quot;, \\\&quot;oas\\\&quot; and \\\&quot;wsdl\\\&quot;. Maximum size of 5 MB. This field must be the last field of the multipart.
func (r DefaultApiAssetsPostRequest) Asset(asset *os.File) DefaultApiAssetsPostRequest {
	r.asset = asset
	return r
}

// Specify API Spec formats that assets are allowed to use
func (r DefaultApiAssetsPostRequest) XAllowedApiSpecFormats(xAllowedApiSpecFormats string) DefaultApiAssetsPostRequest {
	r.xAllowedApiSpecFormats = &xAllowedApiSpecFormats
	return r
}

// The product version of API assets. Required for \\\&quot;raml\\\&quot;, \\\&quot;oas\\\&quot;, \\\&quot;wsdl\\\&quot; and \\\&quot;http\\\&quot; assets
func (r DefaultApiAssetsPostRequest) ApiVersion(apiVersion string) DefaultApiAssetsPostRequest {
	r.apiVersion = &apiVersion
	return r
}

// The main file of the asset. Required for \\\&quot;raml\\\&quot;, \\\&quot;raml-fragment\\\&quot;, \\\&quot;oas\\\&quot; and \\\&quot;wsdl\\\&quot;.
func (r DefaultApiAssetsPostRequest) Main(main string) DefaultApiAssetsPostRequest {
	r.main = &main
	return r
}

// Required for \\\&quot;api-group\\\&quot; classifier only, They are APIs included in it, as a JSON array of objects. Because the field must be of String type, the stringified value of the JSON array must be passed as parameter.
func (r DefaultApiAssetsPostRequest) Dependencies(dependencies string) DefaultApiAssetsPostRequest {
	r.dependencies = &dependencies
	return r
}

// The version of the format of the api specification. ie ‘2.0’ for OAS 2.0
func (r DefaultApiAssetsPostRequest) OriginalFormatVersion(originalFormatVersion string) DefaultApiAssetsPostRequest {
	r.originalFormatVersion = &originalFormatVersion
	return r
}

// A design center object describing asset projectId, branchId and commitId. Because the field must be of String type, the stringified value of the JSON object must be passed as parameter.
func (r DefaultApiAssetsPostRequest) Metadata(metadata string) DefaultApiAssetsPostRequest {
	r.metadata = &metadata
	return r
}

// An array of strings to be saved as asset&#39;s tags. Because the field must be of String type, the stringified value of the JSON array must be passed as parameter.
func (r DefaultApiAssetsPostRequest) Tags(tags string) DefaultApiAssetsPostRequest {
	r.tags = &tags
	return r
}

// The link of the asset. Required for \\\&quot;wsdl\\\&quot; or \\\&quot;http\\\&quot; assets
func (r DefaultApiAssetsPostRequest) AssetLink(assetLink string) DefaultApiAssetsPostRequest {
	r.assetLink = &assetLink
	return r
}

func (r DefaultApiAssetsPostRequest) Execute() (*PostAssetResponse, *http.Response, error) {
	return r.ApiService.AssetsPostExecute(r)
}

/*
AssetsPost Create a new asset

Create a new asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiAssetsPostRequest
*/
func (a *DefaultApiService) AssetsPost(ctx context.Context) DefaultApiAssetsPostRequest {
	return DefaultApiAssetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostAssetResponse
func (a *DefaultApiService) AssetsPostExecute(r DefaultApiAssetsPostRequest) (*PostAssetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostAssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xStrictPackage == nil {
		return localVarReturnValue, nil, reportError("xStrictPackage is required and must be specified")
	}
	if r.organizationId == nil {
		return localVarReturnValue, nil, reportError("organizationId is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}
	if r.version == nil {
		return localVarReturnValue, nil, reportError("version is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.classifier == nil {
		return localVarReturnValue, nil, reportError("classifier is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAllowedApiSpecFormats != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-allowed-api-spec-formats", r.xAllowedApiSpecFormats, "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-strict-package", r.xStrictPackage, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "organizationId", r.organizationId, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "assetId", r.assetId, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "version", r.version, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "classifier", r.classifier, "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "apiVersion", r.apiVersion, "")
	}
	if r.main != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "main", r.main, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "groupId", r.groupId, "")
	var assetLocalVarFormFileName string
	var assetLocalVarFileName     string
	var assetLocalVarFileBytes    []byte

	assetLocalVarFormFileName = "asset"


	assetLocalVarFile := r.asset

	if assetLocalVarFile != nil {
		fbs, _ := io.ReadAll(assetLocalVarFile)

		assetLocalVarFileBytes = fbs
		assetLocalVarFileName = assetLocalVarFile.Name()
		assetLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: assetLocalVarFileBytes, fileName: assetLocalVarFileName, formFileName: assetLocalVarFormFileName})
	}
	if r.dependencies != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "dependencies", r.dependencies, "")
	}
	if r.originalFormatVersion != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "originalFormatVersion", r.originalFormatVersion, "")
	}
	if r.metadata != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "metadata", r.metadata, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "")
	}
	if r.assetLink != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "assetLink", r.assetLink, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiAssetsSearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	types *string
	search *string
	domain *string
	masterOrganizationId *string
	organizationId *string
	offset *int32
	limit *int32
	sort *string
	ascending *string
	sharedWithMe *bool
	includeSnapshots *bool
}

// Filter results that matches the input with the asset type
func (r DefaultApiAssetsSearchGetRequest) Types(types string) DefaultApiAssetsSearchGetRequest {
	r.types = &types
	return r
}

// Filter results that partially match the input with the asset name
func (r DefaultApiAssetsSearchGetRequest) Search(search string) DefaultApiAssetsSearchGetRequest {
	r.search = &search
	return r
}

// Filter results by organization using its domain
func (r DefaultApiAssetsSearchGetRequest) Domain(domain string) DefaultApiAssetsSearchGetRequest {
	r.domain = &domain
	return r
}

// Filter results by master organization id.
func (r DefaultApiAssetsSearchGetRequest) MasterOrganizationId(masterOrganizationId string) DefaultApiAssetsSearchGetRequest {
	r.masterOrganizationId = &masterOrganizationId
	return r
}

// Filter results by organizations. For more than one organization, &amp; organizationId&#x3D;1&amp; organizationId&#x3D;2, etc...
func (r DefaultApiAssetsSearchGetRequest) OrganizationId(organizationId string) DefaultApiAssetsSearchGetRequest {
	r.organizationId = &organizationId
	return r
}

// The offset specifies the offset of the first row to return
func (r DefaultApiAssetsSearchGetRequest) Offset(offset int32) DefaultApiAssetsSearchGetRequest {
	r.offset = &offset
	return r
}

// Amount of objects retrieved in the response
func (r DefaultApiAssetsSearchGetRequest) Limit(limit int32) DefaultApiAssetsSearchGetRequest {
	r.limit = &limit
	return r
}

// Property to sort by
func (r DefaultApiAssetsSearchGetRequest) Sort(sort string) DefaultApiAssetsSearchGetRequest {
	r.sort = &sort
	return r
}

// Order for sorting
func (r DefaultApiAssetsSearchGetRequest) Ascending(ascending string) DefaultApiAssetsSearchGetRequest {
	r.ascending = &ascending
	return r
}

// Retrieve only the assets that has been shared with you
func (r DefaultApiAssetsSearchGetRequest) SharedWithMe(sharedWithMe bool) DefaultApiAssetsSearchGetRequest {
	r.sharedWithMe = &sharedWithMe
	return r
}

// Include snapshots in the results
func (r DefaultApiAssetsSearchGetRequest) IncludeSnapshots(includeSnapshots bool) DefaultApiAssetsSearchGetRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r DefaultApiAssetsSearchGetRequest) Execute() ([]AssetSearchResultItem, *http.Response, error) {
	return r.ApiService.AssetsSearchGetExecute(r)
}

/*
AssetsSearchGet Search for assets

Search for assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiAssetsSearchGetRequest
*/
func (a *DefaultApiService) AssetsSearchGet(ctx context.Context) DefaultApiAssetsSearchGetRequest {
	return DefaultApiAssetsSearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AssetSearchResultItem
func (a *DefaultApiService) AssetsSearchGetExecute(r DefaultApiAssetsSearchGetRequest) ([]AssetSearchResultItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AssetSearchResultItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AssetsSearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.types == nil {
		return localVarReturnValue, nil, reportError("types is required and must be specified")
	}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "")
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.masterOrganizationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "masterOrganizationId", r.masterOrganizationId, "")
	}
	if r.organizationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organizationId", r.organizationId, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.ascending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ascending", r.ascending, "")
	}
	if r.sharedWithMe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sharedWithMe", r.sharedWithMe, "")
	}
	if r.includeSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSnapshots", r.includeSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AssetsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
